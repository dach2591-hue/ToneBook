<!DOCTYPE html>
<!-- Version: v10.9.8-METRONOME-BELOW-INFO - Generated: 2026-01-19 08:00:00 -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToneBook - Chord Transposer & Song Library</title>
    
    <!-- Mobile optimization and icon -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ToneBook">
    <link rel="apple-touch-icon" href="data:image/png;base64,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">
    <link rel="icon" type="image/png" href="data:image/png;base64,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">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Responsive Design for All Devices */
      @media (max-width: 640px) {
        /* Phone styles */
        body { font-size: 14px; }
        /* Removed !important so inline fontSize styles work */
        h1 { font-size: 1.5rem; }
        h2 { font-size: 1.25rem; }
      }
      
      @media (min-width: 641px) and (max-width: 1024px) {
        /* Tablet styles */
        body { font-size: 16px; }
        /* Removed !important so inline fontSize styles work */
      }
      
      @media (min-width: 1920px) {
        /* Large screen / Projector */
        body { font-size: 20px; }
        /* Removed !important so inline fontSize styles work */
        h2 { font-size: 2rem; }
      }
      
      @media (min-width: 2560px) {
        /* Ultra-wide / Large Projector */
        body { font-size: 24px; }
        /* Removed !important so inline fontSize styles work */
        h1 { font-size: 3rem; }
        h2 { font-size: 2.5rem; }
      }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        const Music = ({ size = 24, className = "" }) => (
            <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
            </svg>
        );
        
        const Plus = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        );
        
        const Download = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );
        
        const Copy = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
        );
        
        const FileText = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
        );
        
        const Trash2 = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        );
        
        const Edit = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
        );
        
        const Save = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
            </svg>
        );
        
        const X = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );
        
        const Menu = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        );

        const Columns = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="3" y="3" width="7" height="18" rx="1"></rect>
                <rect x="14" y="3" width="7" height="18" rx="1"></rect>
            </svg>
        );
        
        const Folder = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
            </svg>
        );
        
        const FolderPlus = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                <line x1="12" y1="11" x2="12" y2="17"></line>
                <line x1="9" y1="14" x2="15" y2="14"></line>
            </svg>
        );
        
        const ChevronDown = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
        );
        
        const ChevronRight = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        );

        const ChordTransposer = () => {

// Helper to filter out //measures lines
          const filterMeasureLines = (content) => {
            if (!content) return content;
            return content.split('\n')
              .filter(line => !line.trim().match(/^\/\/\d+\s*(measures?|compases?)/i))
              .join('\n');
          };
          
          // STEP 1: Parser functions for Live Mode
          const parseLiveSections = (content) => {
            try {
              if (!content) return [];
              const lines = content.split('\n');
              const sections = [];
              let currentSection = null;
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // ONLY match lines that are JUST a section header (nothing else on the line)
                // This excludes chords like [G] that appear in lyrics
                const sectionMatch = line.match(/^\[([^\]]+)\]$/);
                let isSection = false;
                
                if (sectionMatch) {
                  const content = sectionMatch[1].trim();
                  // Only treat as section if it's long enough or has spaces
                  // Section names: INTRO, VERSO I, CORO, Instrumental, Final
                  // NOT sections: G, D, Am, Bm, G/B (chords)
                  if (content.length >= 4 || content.includes(' ')) {
                    isSection = true;
                  }
                }
                
                if (isSection) {
                  if (currentSection) sections.push(currentSection);
                  
                  const fullText = sectionMatch[1];
                  const repeatMatch = fullText.match(/x(\d+)/i);
                  const repeatCount = repeatMatch ? parseInt(repeatMatch[1]) : 1;
                  const sectionName = fullText.replace(/x\d+/i, '').trim();
                  
                  currentSection = {
                    name: sectionName,
                    repeat: repeatCount,
                    measures: 8,
                    content: []
                  };
                  
                  // Check for //8 measures or 8 measures
                  if (i + 1 < lines.length) {
                    const nextLine = lines[i + 1].trim();
                    const commentMatch = nextLine.match(/^\/\/(\d+)\s*(measures?|compases?)/i);
                    if (commentMatch) {
                      currentSection.measures = parseInt(commentMatch[1]);
                      i++;
                    } else {
                      const regularMatch = nextLine.match(/^(\d+)\s*(measures?|compases?)/i);
                      if (regularMatch) {
                        currentSection.measures = parseInt(regularMatch[1]);
                      }
                    }
                  }
                } else if (currentSection) {
                  // Add line to content if it's not a comment
                  if (!line.startsWith('//')) {
                    currentSection.content.push(lines[i]);
                  }
                }
              }
              
              if (currentSection) sections.push(currentSection);
              return sections;
            } catch (err) {
              console.error('Parser error:', err);
              return [];
            }
          };
          
          const calculateSectionDuration = (measures, bpm, timeSignature, repeat = 1) => {
            try {
              const beatsPerMeasure = timeSignature ? parseInt(timeSignature.split('/')[0]) : 4;
              const totalBeats = measures * beatsPerMeasure * repeat; // Multiply by repeat!
              const beatsPerSecond = bpm / 60;
              return totalBeats / beatsPerSecond;
            } catch (err) {
              return 10;
            }
          };
          const [songs, setSongs] = useState([]);
          const [currentSong, setCurrentSong] = useState(null);
          const [editMode, setEditMode] = useState(false);
          const [title, setTitle] = useState('');
          const [content, setContent] = useState('');
          const [songKey, setSongKey] = useState('');
          const [bpm, setBpm] = useState('');
          const [timeSignature, setTimeSignature] = useState('');
          const [transposition, setTransposition] = useState(0);
          const [showNewSong, setShowNewSong] = useState(false);
          const [viewMode, setViewMode] = useState(false);
          const [searchQuery, setSearchQuery] = useState('');
          const [showImportModal, setShowImportModal] = useState(false);
          const [importText, setImportText] = useState('');
          const [viewDisplayMode, setViewDisplayMode] = useState('chords');
          const [columnLayout, setColumnLayout] = useState(1);
          const [draggedSong, setDraggedSong] = useState(null);
          const [metronomeActive, setMetronomeActive] = useState(false);
          const [metronomeBpm, setMetronomeBpm] = useState(120);
          const [currentBeat, setCurrentBeat] = useState(0);
          const [folders, setFolders] = useState([]);
          const [selectedFolder, setSelectedFolder] = useState('all');
          const [collapsedFolders, setCollapsedFolders] = useState({});
          const [showNewFolderModal, setShowNewFolderModal] = useState(false);
          const [newFolderName, setNewFolderName] = useState('');
          const [showMoveSongModal, setShowMoveSongModal] = useState(false);
          const [songToMove, setSongToMove] = useState(null);
          const [showImportFolderModal, setShowImportFolderModal] = useState(false);
          const [importedSongsData, setImportedSongsData] = useState(null);
          const [importFolderName, setImportFolderName] = useState('');
          const [showDuplicateModal, setShowDuplicateModal] = useState(false);
          const [duplicateSongs, setDuplicateSongs] = useState([]);
          const [selectedFolderForImport, setSelectedFolderForImport] = useState(null);
          const [showExportModal, setShowExportModal] = useState(false);
          const [showLiveMode, setShowLiveMode] = useState(false);
          const [liveSectionIndex, setLiveSectionIndex] = useState(0);
          const [liveIsPlaying, setLiveIsPlaying] = useState(false);
          const [liveProgress, setLiveProgress] = useState(0);
          const [liveFontSize, setLiveFontSize] = useState(130);
          const [metronomeBeat, setMetronomeBeat] = useState(0);
          const [metronomeAudioMuted, setMetronomeAudioMuted] = useState(true);
          const [performanceFontSize, setPerformanceFontSize] = useState(100);
          const [menuVisible, setMenuVisible] = useState(true);
          const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
          const menuTimeoutRef = React.useRef(null);
          
          const metronomeIntervalRef = React.useRef(null);
          const audioContextRef = React.useRef(null);

          useEffect(() => {
            loadSongs();
          
          

          }, []);
          
          // AUTO-ADVANCE TIMER FOR LIVE MODE
          useEffect(() => {
            if (window.liveTimer) {
              clearInterval(window.liveTimer);
            }
            
            if (!liveIsPlaying || !currentSong) return;
            
            // Parse sections from content
            const parsedSections = parseLiveSections(currentSong.content);
            const section = parsedSections[liveSectionIndex];
            if (!section) return;
            
            const bpm = parseInt(currentSong.bpm) || 120;
            const duration = calculateSectionDuration(
              section.measures, 
              bpm, 
              currentSong.timeSignature || '4/4', 
              section.repeat
            );
            
            const startTime = Date.now();
            const startProg = liveProgress;
            
            window.liveTimer = setInterval(() => {
              const elapsed = (Date.now() - startTime) / 1000;
              const newProg = startProg + ((elapsed / duration) * (100 - startProg));
              
              if (newProg >= 100) {
                clearInterval(window.liveTimer);
                setLiveProgress(100);
                console.log(' Done!');
                
                setTimeout(() => {
                  const parsedSections = parseLiveSections(currentSong.content);
                  if (liveSectionIndex < parsedSections.length - 1) {
                    console.log(' Next section');
                    setLiveSectionIndex(liveSectionIndex + 1);
                    setLiveProgress(0);
                  } else {
                    console.log(' Finished!');
                    setLiveIsPlaying(false);
                  }
                }, 300);
              } else {
                setLiveProgress(newProg);
              }
            }, 50);
            
            return () => {
              if (window.liveTimer) clearInterval(window.liveTimer);
            };
          }, [liveIsPlaying, liveSectionIndex]);

          // Metronome AUDIO + VISUAL in Live Mode
          useEffect(() => {
            if (!liveIsPlaying || !metronomeActive) return;
            
            const bpm = parseInt(currentSong?.bpm) || 120;
            const interval = (60 / bpm) * 1000;
            const timeSignature = currentSong?.timeSignature || '4/4';
            const beats = parseInt(timeSignature.split('/')[0]);
            
            // Create AudioContext for metronome sound
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const playClick = (isFirstBeat) => {
              if (metronomeAudioMuted) return; // Skip if muted
              
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);
              
              // First beat of measure is higher pitch
              oscillator.frequency.value = isFirstBeat ? 1000 : 800;
              gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
              
              oscillator.start(audioContext.currentTime);
              oscillator.stop(audioContext.currentTime + 0.1);
            };
            
            let beat = 0;
            
            // Play first click immediately
            playClick(true);
            setMetronomeBeat(0);
            
            const timer = setInterval(() => {
              beat++;
              const currentBeat = beat % beats;
              setMetronomeBeat(currentBeat);
              playClick(currentBeat === 0);
            }, interval);
            
            return () => {
              clearInterval(timer);
              audioContext.close();
            };
          }, [liveIsPlaying, metronomeActive, currentSong, metronomeAudioMuted]);
          
          const loadSongs = () => {
            const savedSongs = localStorage.getItem('chordTransposerSongs');
            if (savedSongs) {
              const loadedSongs = JSON.parse(savedSongs);
              // Ensure songs have folders array
              const songsWithFolders = loadedSongs.map(s => ({
                ...s,
                folders: s.folders || []
              }));
              setSongs(songsWithFolders);
            }
            
            const savedFolders = localStorage.getItem('chordTransposerFolders');
            if (savedFolders) {
              setFolders(JSON.parse(savedFolders));
            }
          };

          const saveSong = () => {
            if (!title.trim() || !content.trim()) {
              alert('Please add a title and content');
              return;
            }

            const chords = extractChords(content);
            const detectedKey = songKey.trim() || detectKey(chords);
            
            const song = {
              id: currentSong?.id || Date.now().toString(),
              title: title.trim(),
              content: content.trim(),
              originalKey: detectedKey,
              bpm: bpm.trim(),
              timeSignature: timeSignature.trim(),
              pinned: currentSong?.pinned || false,
              folders: currentSong?.folders || [],
              createdAt: currentSong?.createdAt || new Date().toISOString()
            };

            const updatedSongs = currentSong 
              ? songs.map(s => s.id === song.id ? song : s)
              : [...songs, song];
            console.log("Saving song with folders:", song.folders);
            
            setSongs(updatedSongs);
            localStorage.setItem('chordTransposerSongs', JSON.stringify(updatedSongs));
            setCurrentSong(song);
            setTransposition(0);
            setEditMode(false);
            setShowNewSong(false);
          };

          const deleteSong = (songId) => {
            if (!confirm('Delete this song?')) return;
            
            const updatedSongs = songs.filter(s => s.id !== songId);
            setSongs(updatedSongs);
            localStorage.setItem('chordTransposerSongs', JSON.stringify(updatedSongs));
            
            if (currentSong?.id === songId) {
              setCurrentSong(null);
              setTransposition(0);
            }
          };

          const loadSong = (song) => {
            setCurrentSong(song);
            setTitle(song.title);
            setContent(song.content);
            setSongKey(song.originalKey);
            setBpm(song.bpm || '');
            setTimeSignature(song.timeSignature || '');
            setTransposition(0);
            setEditMode(false);
            setShowNewSong(false);
            setViewMode(false);
            setViewDisplayMode('chords');
            setMobileMenuOpen(false); // Close mobile menu when song is selected
          };

          const startNewSong = () => {
            setCurrentSong(null);
            setTitle('');
            setContent('');
            setSongKey('');
            setBpm('');
            setTimeSignature('');
            setTransposition(0);
            setEditMode(true);
            setShowNewSong(true);
          };
	const parseImportedText = () => {
            if (!importText.trim()) {
              alert('Please paste some text to import');
              return;
            }

            const lines = importText.split('\n');
            let parsedContent = '';
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              const trimmedLine = line.trim();
              
              if (!trimmedLine) {
                parsedContent += '\n';
                continue;
              }
              
              const chordPattern = /^[A-G][#b]?(m|maj|min|dim|aug|sus|add)?[0-9]*(\/[A-G][#b]?)?(\s+[A-G][#b]?(m|maj|min|dim|aug|sus|add)?[0-9]*(\/[A-G][#b]?)?)*\s*$/;
              const possibleChordLine = chordPattern.test(trimmedLine);
              
              if (possibleChordLine) {
                const chords = [];
                const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
                
                // Extract chords with their positions
                const chordRegex = /[A-G][#b]?(m|maj|min|dim|aug|sus|add)?[0-9]*(\/[A-G][#b]?)?/g;
                let match;
                while ((match = chordRegex.exec(line)) !== null) {
                  chords.push({ chord: match[0], pos: match.index });
                }
                
                if (nextLine.trim()) {
                  // Build the chord line with brackets and proper spacing
                  let chordLine = '';
                  
                  chords.forEach((item) => {
                    // Add spaces to reach the chord position
                    while (chordLine.length < item.pos) {
                      chordLine += ' ';
                    }
                    // Add chord with brackets
                    chordLine += `[${item.chord}]`;
                  });
                  
                  // Add the chord line and lyrics line
                  parsedContent += chordLine + '\n';
                  parsedContent += nextLine + '\n';
                  i++; // Skip the next line since we've already processed it
                } else {
                  // Just chords, no lyrics below
                  parsedContent += chords.map(c => `[${c.chord}]`).join(' ') + '\n';
                }
              } else {
                let processedLine = trimmedLine;
                
                processedLine = processedLine.replace(/\(([A-G][#b]?(?:m|maj|min|dim|aug|sus|add)?[0-9]*(?:\/[A-G][#b]?)?)\)/g, '[$1]');
                processedLine = processedLine.replace(/\{([A-G][#b]?(?:m|maj|min|dim|aug|sus|add)?[0-9]*(?:\/[A-G][#b]?)?)\}/g, '[$1]');
                
                const sectionPattern = /^(\[?(?:INTRO|VERSE|CHORUS|BRIDGE|OUTRO|CORO|VERSO|PUENTE|INSTRUMENTAL|PRE-CHORUS|PRE CHORUS|INTERLUDE|SOLO)(?:\s+\d+)?[\]:]?\s*)$/i;
                if (sectionPattern.test(trimmedLine)) {
                  const sectionMatch = trimmedLine.match(/(?:INTRO|VERSE|CHORUS|BRIDGE|OUTRO|CORO|VERSO|PUENTE|INSTRUMENTAL|PRE-CHORUS|PRE CHORUS|INTERLUDE|SOLO)(?:\s+\d+)?/i);
                  if (sectionMatch) {
                    parsedContent += `[${sectionMatch[0]}]\n`;
                  } else {
                    parsedContent += processedLine + '\n';
                  }
                } else {
                  parsedContent += processedLine + '\n';
                }
              }
            }
            
            setContent(parsedContent.trim());
            setShowImportModal(false);
            setImportText('');
            alert('Text imported! Please review and adjust the formatting as needed.');
          };

          const startEdit = () => {
            setEditMode(true);
          };

          const cancelEdit = () => {
            if (currentSong) {
              setTitle(currentSong.title);
              setContent(currentSong.content);
              setSongKey(currentSong.originalKey);
              setBpm(currentSong.bpm || '');
              setTimeSignature(currentSong.timeSignature || '');
              setEditMode(false);
            } else {
              setShowNewSong(false);
              setTitle('');
              setContent('');
              setSongKey('');
              setBpm('');
              setTimeSignature('');
            }
          };

          const togglePin = (songId, e) => {
            e.stopPropagation();
            const updatedSongs = songs.map(s => 
              s.id === songId ? { ...s, pinned: !s.pinned } : s
            );
            setSongs(updatedSongs);
            localStorage.setItem('chordTransposerSongs', JSON.stringify(updatedSongs));
            if (currentSong?.id === songId) {
              setCurrentSong({ ...currentSong, pinned: !currentSong.pinned });
            }
          };

          const handleDragStart = (e, song) => {
            setDraggedSong(song);
            e.dataTransfer.effectAllowed = 'move';
          };

          const handleDragOver = (e, targetSong) => {
            e.preventDefault();
            if (!draggedSong || draggedSong.id === targetSong.id) return;
            
            const pinnedSongs = songs.filter(s => s.pinned);
            const unpinnedSongs = songs.filter(s => !s.pinned);
            
            const draggedIndex = pinnedSongs.findIndex(s => s.id === draggedSong.id);
            const targetIndex = pinnedSongs.findIndex(s => s.id === targetSong.id);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            const newPinnedSongs = [...pinnedSongs];
            newPinnedSongs.splice(draggedIndex, 1);
            newPinnedSongs.splice(targetIndex, 0, draggedSong);
            
            const newSongs = [...newPinnedSongs, ...unpinnedSongs];
            setSongs(newSongs);
          };

          const handleDragEnd = () => {
            if (draggedSong) {
              localStorage.setItem('chordTransposerSongs', JSON.stringify(songs));
            }
            setDraggedSong(null);
          };

          // Move pinned song up in order
          const movePinnedSongUp = (songId, e) => {
            e.stopPropagation();
            const pinnedSongs = songs.filter(s => s.pinned);
            const unpinnedSongs = songs.filter(s => !s.pinned);
            const currentIndex = pinnedSongs.findIndex(s => s.id === songId);
            
            if (currentIndex > 0) {
              const newPinnedSongs = [...pinnedSongs];
              [newPinnedSongs[currentIndex - 1], newPinnedSongs[currentIndex]] = 
                [newPinnedSongs[currentIndex], newPinnedSongs[currentIndex - 1]];
              
              const newSongs = [...newPinnedSongs, ...unpinnedSongs];
              setSongs(newSongs);
              localStorage.setItem('chordTransposerSongs', JSON.stringify(newSongs));
            }
          };

          // Move pinned song down in order
          const movePinnedSongDown = (songId, e) => {
            e.stopPropagation();
            const pinnedSongs = songs.filter(s => s.pinned);
            const unpinnedSongs = songs.filter(s => !s.pinned);
            const currentIndex = pinnedSongs.findIndex(s => s.id === songId);
            
            if (currentIndex < pinnedSongs.length - 1) {
              const newPinnedSongs = [...pinnedSongs];
              [newPinnedSongs[currentIndex], newPinnedSongs[currentIndex + 1]] = 
                [newPinnedSongs[currentIndex + 1], newPinnedSongs[currentIndex]];
              
              const newSongs = [...newPinnedSongs, ...unpinnedSongs];
              setSongs(newSongs);
              localStorage.setItem('chordTransposerSongs', JSON.stringify(newSongs));
            }
          };

          // Go to next pinned song
          const goToNextSong = () => {
            const pinnedSongs = songs.filter(s => s.pinned);
            if (pinnedSongs.length === 0) return;
            
            const currentIndex = pinnedSongs.findIndex(s => s.id === currentSong?.id);
            const nextIndex = (currentIndex + 1) % pinnedSongs.length; // Wrap around to first
            const nextSong = pinnedSongs[nextIndex];
            
            if (nextSong) {
              // Save current view state
              const wasInPerformanceMode = viewMode;
              const wasInLiveMode = showLiveMode;
              
              // Load the song
              loadSong(nextSong);
              
              // Restore Performance/Live Mode
              if (wasInPerformanceMode) {
                setViewMode(true);
              }
              if (wasInLiveMode) {
                setShowLiveMode(true);
                setLiveSectionIndex(0);
                setLiveProgress(0);
                setLiveIsPlaying(false);
                if (window.liveTimer) {
                  clearInterval(window.liveTimer);
                  window.liveTimer = null;
                }
              }
            }
          };

          // Go to previous pinned song
          const goToPreviousSong = () => {
            const pinnedSongs = songs.filter(s => s.pinned);
            if (pinnedSongs.length === 0) return;
            
            const currentIndex = pinnedSongs.findIndex(s => s.id === currentSong?.id);
            const prevIndex = currentIndex <= 0 ? pinnedSongs.length - 1 : currentIndex - 1; // Wrap around to last
            const prevSong = pinnedSongs[prevIndex];
            
            if (prevSong) {
              // Save current view state
              const wasInPerformanceMode = viewMode;
              const wasInLiveMode = showLiveMode;
              
              // Load the song
              loadSong(prevSong);
              
              // Restore Performance/Live Mode
              if (wasInPerformanceMode) {
                setViewMode(true);
              }
              if (wasInLiveMode) {
                setShowLiveMode(true);
                setLiveSectionIndex(0);
                setLiveProgress(0);
                setLiveIsPlaying(false);
                if (window.liveTimer) {
                  clearInterval(window.liveTimer);
                  window.liveTimer = null;
                }
              }
            }
          };

          const playMetronomeClick = (isAccent = false) => {
            if (!audioContextRef.current) {
              audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const ctx = audioContextRef.current;
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);
            
            // Accent beat is higher pitch and louder
            oscillator.frequency.value = isAccent ? 1200 : 800;
            gainNode.gain.value = isAccent ? 0.3 : 0.15;
            
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.05);
          };

          const toggleMetronome = () => {
            if (metronomeActive) {
              // Stop metronome
              if (metronomeIntervalRef.current) {
                clearInterval(metronomeIntervalRef.current);
                metronomeIntervalRef.current = null;
              }
              setMetronomeActive(false);
              setCurrentBeat(0);
            } else {
              // Start metronome
              const bpmToUse = metronomeBpm || 120;
              const interval = (60 / bpmToUse) * 1000; // Convert BPM to milliseconds
              
              // Get beats per measure from time signature
              let beatsPerMeasure = 4;
              if (currentSong?.timeSignature) {
                const match = currentSong.timeSignature.match(/^(\d+)/);
                if (match) beatsPerMeasure = parseInt(match[1]);
              }
              
              let beat = 0;
              playMetronomeClick(true); // First beat accent
              setCurrentBeat(1);
              
              metronomeIntervalRef.current = setInterval(() => {
                beat = (beat + 1) % beatsPerMeasure;
                playMetronomeClick(beat === 0);
                setCurrentBeat(beat + 1);
              }, interval);
              
              setMetronomeActive(true);
            }
          };

          const adjustMetronomeBpm = (change) => {
            const newBpm = Math.max(40, Math.min(240, metronomeBpm + change));
            setMetronomeBpm(newBpm);
            
            // If metronome is active, restart with new BPM
            if (metronomeActive) {
              setMetronomeActive(false);
              if (metronomeIntervalRef.current) {
                clearInterval(metronomeIntervalRef.current);
              }
              setTimeout(() => {
                setMetronomeActive(true);
              }, 100);
            }
          };

          // Initialize metronome BPM when song changes
          React.useEffect(() => {
            if (currentSong && viewMode) {
              const songBpm = parseInt(currentSong.bpm) || 120;
              setMetronomeBpm(songBpm);
            }
            
            // Clear Performance metronome interval when exiting view mode (but keep metronomeActive for Live Mode!)
            if (!viewMode && metronomeIntervalRef.current) {
              clearInterval(metronomeIntervalRef.current);
              metronomeIntervalRef.current = null;
              setCurrentBeat(0);
            }
            // NOTE: Don't set metronomeActive to false! Live Mode needs it!
          }, [currentSong, viewMode]);

          
          // Auto-hide menu in view mode
          React.useEffect(() => {
            if (!viewMode) {
              setMenuVisible(true);
              if (menuTimeoutRef.current) {
                clearTimeout(menuTimeoutRef.current);
              }
              return;
            }

            const handleActivity = () => {
              setMenuVisible(true);
              
              if (menuTimeoutRef.current) {
                clearTimeout(menuTimeoutRef.current);
              }
              
              menuTimeoutRef.current = setTimeout(() => {
                setMenuVisible(false);
              }, 5000);
            };

            const handleScroll = () => handleActivity();
            const handleMouseMove = (e) => {
              if (e.clientY < 150) {
                handleActivity();
              }
            };
            const handleTouchStart = (e) => {
              if (e.touches[0].clientY < 150) {
                handleActivity();
              }
            };

            window.addEventListener('scroll', handleScroll);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('touchstart', handleTouchStart);
            
            handleActivity();

            return () => {
              window.removeEventListener('scroll', handleScroll);
              window.removeEventListener('mousemove', handleMouseMove);
              window.removeEventListener('touchstart', handleTouchStart);
              if (menuTimeoutRef.current) {
                clearTimeout(menuTimeoutRef.current);
              }
            };
          }, [viewMode]);

          // Restart metronome when BPM changes while active
          React.useEffect(() => {
            if (metronomeActive && metronomeIntervalRef.current) {
              clearInterval(metronomeIntervalRef.current);
              
              const bpmToUse = metronomeBpm || 120;
              const interval = (60 / bpmToUse) * 1000;
              
              let beatsPerMeasure = 4;
              if (currentSong?.timeSignature) {
                const match = currentSong.timeSignature.match(/^(\d+)/);
                if (match) beatsPerMeasure = parseInt(match[1]);
              }
              
              let beat = 0;
              metronomeIntervalRef.current = setInterval(() => {
                beat = (beat + 1) % beatsPerMeasure;
                playMetronomeClick(beat === 0);
                setCurrentBeat(beat + 1);
              }, interval);
            }
          }, [metronomeBpm, metronomeActive]);

          const createFolder = () => {
            if (!newFolderName.trim()) {
              alert('Please enter a folder name');
              return;
            }
            
            const folder = {
              id: Date.now().toString(),
              name: newFolderName.trim(),
              createdAt: new Date().toISOString()
            };
            
            const updatedFolders = [...folders, folder];
            setFolders(updatedFolders);
            localStorage.setItem('chordTransposerFolders', JSON.stringify(updatedFolders));
            setNewFolderName('');
            setShowNewFolderModal(false);
          };

          const deleteFolder = (folderId) => {
            if (!confirm('Delete this folder? Songs will not be deleted, just removed from the folder.')) return;
            
            // Remove folder
            const updatedFolders = folders.filter(f => f.id !== folderId);
            setFolders(updatedFolders);
            localStorage.setItem('chordTransposerFolders', JSON.stringify(updatedFolders));
            
            // Remove folder from all songs
            const updatedSongs = songs.map(s => ({
              ...s,
              folders: (s.folders || []).filter(fId => fId !== folderId)
            }));
            setSongs(updatedSongs);
            localStorage.setItem('chordTransposerSongs', JSON.stringify(updatedSongs));
            
            if (selectedFolder === folderId) {
              setSelectedFolder('all');
            }
          };

          const addSongToFolder = (songId, folderId) => {
            const updatedSongs = songs.map(s => {
              if (s.id === songId) {
                const folders = s.folders || [];
                if (!folders.includes(folderId)) {
                  return { ...s, folders: [...folders, folderId] };
                }
              }
              return s;
            });
            setSongs(updatedSongs);
            localStorage.setItem('chordTransposerSongs', JSON.stringify(updatedSongs));
          };

          const removeSongFromFolder = (songId, folderId) => {
            const updatedSongs = songs.map(s => {
              if (s.id === songId) {
                return {
                  ...s,
                  folders: (s.folders || []).filter(fId => fId !== folderId)
                };
              }
              return s;
            });
            setSongs(updatedSongs);
            localStorage.setItem('chordTransposerSongs', JSON.stringify(updatedSongs));
          };

          const toggleFolderCollapse = (folderId) => {
            setCollapsedFolders(prev => ({
              ...prev,
              [folderId]: !prev[folderId]
            }));
          };

          const openMoveSongModal = (song) => {
            setSongToMove(song);
            setShowMoveSongModal(true);
          };

          const isChord = (text) => {
            const chordPattern = /^[A-G][#b]?(m|maj|min|dim|aug|sus|add)?[0-9]*(\/[A-G][#b]?)?$/;
            return chordPattern.test(text.trim());
          };

          const extractChords = (text) => {
            const chordRegex = /\[([^\]]+)\]/g;
            const matches = [...text.matchAll(chordRegex)];
            return matches.map(m => m[1]).filter(isChord);
          };

          const detectKey = (chords) => {
            if (chords.length === 0) return 'C';
            const firstChord = chords[0].split('/')[0].replace(/[^A-G#b]/g, '');
            return firstChord || 'C';
          };

          const transposeChord = (chord, semitones, songKey = 'C') => {
            // If no transposition, return original chord exactly as written
            if (semitones === 0) return chord;
            
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const flatNotes = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
            const flatToSharp = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };
            const sharpToFlat = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
            
            // Determine if we should use flats or sharps based on the song key
            const keyRoot = songKey.replace(/m.*$/, ''); // Remove minor and other suffixes
            const sharpKeys = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'];
            const flatKeys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'];
            const useFlats = flatKeys.includes(keyRoot);
            
            if (chord.includes('/')) {
              const [main, bass] = chord.split('/');
              return transposeChord(main, semitones, songKey) + '/' + transposeChord(bass, semitones, songKey);
            }
            
            const chordMatch = chord.match(/^([A-G][#b]?)(.*)/);
            if (!chordMatch) return chord;
            
            let [, root, suffix] = chordMatch;
            root = flatToSharp[root] || root;
            
            const index = notes.indexOf(root);
            if (index === -1) return chord;
            
            const newIndex = (index + semitones + 12) % 12;
            let newRoot = notes[newIndex];
            
            // Use flats if the song key is a flat key, otherwise use sharps
            if (useFlats && sharpToFlat[newRoot]) {
              newRoot = sharpToFlat[newRoot];
            }
            
            return newRoot + suffix;
          };

          const getCurrentKey = () => {
            if (!currentSong) return 'C';
            if (transposition === 0) return currentSong.originalKey;
            return transposeChord(currentSong.originalKey, transposition, currentSong.originalKey);
          };

          const chordToNumeral = (chord, key) => {
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const flatToSharp = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };
            
            if (chord.includes('/')) {
              const [main, bass] = chord.split('/');
              return chordToNumeral(main, key) + '/' + chordToNumeral(bass, key);
            }
            
            const chordMatch = chord.match(/^([A-G][#b]?)(.*)/);
            if (!chordMatch) return chord;
            
            let [, root, suffix] = chordMatch;
            root = flatToSharp[root] || root;
            let keyNote = flatToSharp[key] || key;
            
            const rootIndex = notes.indexOf(root);
            const keyIndex = notes.indexOf(keyNote);
            
            if (rootIndex === -1 || keyIndex === -1) return chord;
            
            let interval = (rootIndex - keyIndex + 12) % 12;
            
            const intervalToNumeral = {
              0: { numeral: 'I', quality: '' },
              1: { numeral: 'IIb', quality: '' },
              2: { numeral: 'II', quality: 'm' },
              3: { numeral: 'IIIb', quality: '' },
              4: { numeral: 'III', quality: 'm' },
              5: { numeral: 'IV', quality: '' },
              6: { numeral: 'Vb', quality: '' },
              7: { numeral: 'V', quality: '' },
              8: { numeral: 'VIb', quality: '' },
              9: { numeral: 'VI', quality: 'm' },
              10: { numeral: 'VIIb', quality: '' },
              11: { numeral: 'VII', quality: 'dim' }
            };
            
            const numeralInfo = intervalToNumeral[interval];
            let numeral = numeralInfo.numeral;
            
            if (suffix.includes('m') && numeralInfo.quality === '') {
              numeral = numeral.toLowerCase();
            } else if (!suffix.includes('m') && numeralInfo.quality === 'm') {
              numeral = numeral.toUpperCase();
            } else if (suffix.includes('dim')) {
              numeral += 'dim';
            }
            
            const cleanSuffix = suffix.replace(/^m/, '').replace(/^dim/, '');
            
            return numeral + cleanSuffix;
          };

          const formatContent = (text, transpose = 0, displayMode = 'chords', songKey = 'C') => {
            const lines = text.split('\n');
            return lines.map((line) => {
              const parts = [];
              let lastIndex = 0;
              
              const chordRegex = /\[([^\]]+)\]/g;
              let match;
              
              while ((match = chordRegex.exec(line)) !== null) {
                if (match.index > lastIndex) {
                  parts.push({ type: 'text', content: line.slice(lastIndex, match.index) });
                }
                
                const bracketContent = match[1];
                
                if (isChord(bracketContent)) {
                  if (displayMode === 'lyrics') {
                  } else if (displayMode === 'numbers') {
                    const numeral = chordToNumeral(bracketContent, songKey);
                    parts.push({ type: 'chord', content: numeral });
                  } else {
                    const transposedChord = transposeChord(bracketContent, transpose, songKey);
                    parts.push({ type: 'chord', content: transposedChord });
                  }
                } else {
                  parts.push({ type: 'section', content: bracketContent });
                }
                
                lastIndex = match.index + match[0].length;
              }
              
              if (lastIndex < line.length) {
                parts.push({ type: 'text', content: line.slice(lastIndex) });
              }
              
              return { parts, isEmpty: parts.length === 0 };
            });
          };
const copyToClipboard = async () => {
            const formattedLines = formatContent(currentSong.content, transposition);
            let text = currentSong.title + '\n';
            
            if (transposition !== 0) {
              text += `Original: ${currentSong.originalKey}, Current: ${getCurrentKey()}\n`;
            }
            if (currentSong.bpm) {
              text += `BPM: ${currentSong.bpm}\n`;
            }
            if (currentSong.timeSignature) {
              text += `Time: ${currentSong.timeSignature}\n`;
            }
            text += '\n';
            
            formattedLines.forEach(line => {
              line.parts.forEach(part => {
                text += part.content;
              });
              text += '\n';
            });
            
            await navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
          };

          const exportToPDF = () => {
            const formattedLines = formatContent(currentSong.content, transposition);
            const printWindow = window.open('', '', 'width=800,height=600');
            
            let htmlContent = `<html><head><meta charset="UTF-8"><title>${currentSong.title}</title>
              <style>
                body { font-family: Arial, sans-serif; padding: 40px; line-height: 1.6; }
                h1 { font-size: 24px; margin-bottom: 10px; font-weight: bold; }
                .info { font-size: 12px; color: #666; margin-bottom: 20px; }
                .chord { font-weight: bold; color: #000; }
                .section { font-size: 18px; font-weight: bold; color: #1d4ed8; margin-top: 16px; margin-bottom: 8px; display: block; }
                .line { margin-bottom: 5px; white-space: pre-wrap; font-family: 'Courier New', monospace; }
                @media print { body { padding: 20px; } }
              </style>    <style>
      /* Responsive Design for All Devices */
      
      /* Sidebar - Desktop and Mobile */
      .sidebar-container {
        position: relative;
      }
      
      @media (max-width: 768px) {
        /* Phone and small tablet styles */
        body { font-size: 14px; }
        /* Removed !important so inline fontSize styles work */
        h1 { font-size: 1.5rem; }
        h2 { font-size: 1.25rem; }
        
        /* Transform sidebar to mobile overlay */
        .sidebar-container {
          position: fixed !important;
          top: 0;
          left: 0;
          bottom: 0;
          z-index: 1000;
          transform: translateX(-100%);
          transition: transform 0.3s ease;
          box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        .sidebar-container.mobile-open {
          transform: translateX(0);
        }
        
        /* Overlay backdrop */
        .mobile-backdrop {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0,0,0,0.5);
          z-index: 999;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.3s ease;
        }
        
        .mobile-backdrop.show {
          opacity: 1;
          pointer-events: auto;
        }
        
        /* Performance Mode Header - Stack vertically */
        .performance-header-mobile {
          flex-direction: column !important;
          gap: 0.75rem !important;
          align-items: stretch !important;
        }
        
        .performance-header-mobile > div {
          width: 100% !important;
        }
        
        .performance-header-mobile button {
          flex: 1 !important;
          min-width: 0 !important;
        }
        
        /* Performance Mode Buttons - Smaller */
        .performance-buttons {
          width: 100% !important;
          flex-wrap: wrap !important;
        }
        
        .performance-buttons button {
          padding: 0.5rem 0.75rem !important;
          font-size: 0.75rem !important;
          flex: 1 !important;
          min-width: 80px !important;
        }
        
        /* Live Mode Controls - Compact layout */
        .live-controls {
          padding: 0.5rem !important;
          gap: 0.5rem !important;
        }
        
        .live-controls button {
          font-size: 0.75rem !important;
        }
        
        .live-font-controls {
          font-size: 0.7rem !important;
        }
        
        .live-font-controls span {
          font-size: 0.7rem !important;
        }
        
        .live-font-controls button {
          width: 1.5rem !important;
          height: 1.5rem !important;
          font-size: 0.7rem !important;
        }
        
        
        /* Metronome and transport controls */
        .live-transport {
          display: flex !important;
          gap: 0.5rem !important;
          align-items: center !important;
        }
        
        /* Song info in Performance/Live headers */
        .song-info-mobile h2 {
          font-size: 1.125rem !important;
        }
        
        .song-info-mobile .text-sm {
          font-size: 0.7rem !important;
        }
        
        .song-info-mobile {
          flex: 1 !important;
          min-width: 0 !important;
        }
        
        /* Transpose controls */
        .transpose-control {
          flex-direction: row !important;
          gap: 0.5rem !important;
          flex-wrap: wrap !important;
          justify-content: center !important;
        }
        
        .transpose-control button {
          padding: 0.5rem 0.75rem !important;
          min-width: 2.5rem !important;
        }
        
        .transpose-control span {
          font-size: 0.875rem !important;
        }
      }
      
      @media (max-width: 640px) {
        /* Extra small phones */
        body { font-size: 13px; }
        h1 { font-size: 1.25rem !important; }
        h2 { font-size: 1.1rem !important; }
        
        .live-controls {
          font-size: 0.8rem !important;
        }
        
        .live-controls button {
          padding: 0.4rem 0.6rem !important;
          font-size: 0.8rem !important;
        }
      }
      
      @media (min-width: 769px) and (max-width: 1024px) {
        /* Tablet styles */
        body { font-size: 16px; }
        .font-mono { font-size: 1.1rem !important; }
      }
      
      @media (min-width: 769px) {
        /* Desktop - Exit Live button integrated in control bar */
        .live-mode-exit {
          position: relative !important;
          top: auto !important;
          right: auto !important;
          z-index: auto !important;
          padding: 0.5rem 1rem !important;
          font-size: 0.875rem !important;
        }
        
        .live-controls {
          justify-content: space-between !important;
        }
      }
      
      @media (min-width: 1920px) {
        /* Large screen / Projector */
        body { font-size: 20px; }
        .font-mono { font-size: 1.4rem !important; }
        h2 { font-size: 2rem !important; }
      }
      
      @media (min-width: 2560px) {
        /* Ultra-wide / Large Projector */
        body { font-size: 24px; }
        .font-mono { font-size: 1.8rem !important; }
        h1 { font-size: 3rem !important; }
        h2 { font-size: 2.5rem !important; }
      }
    </style>
</head><body><h1>${currentSong.title}</h1><div class="info">`;
            
            if (transposition !== 0) {
              htmlContent += `Original: ${currentSong.originalKey}, Current: ${getCurrentKey()}<br>`;
            } else {
              htmlContent += `Key: ${currentSong.originalKey}<br>`;
            }
            if (currentSong.bpm) htmlContent += `BPM: ${currentSong.bpm}<br>`;
            if (currentSong.timeSignature) htmlContent += `Time: ${currentSong.timeSignature}<br>`;
            htmlContent += `</div>`;
            
            formattedLines.forEach(line => {
              htmlContent += '<div class="line">';
              if (line.isEmpty) {
                htmlContent += '<br>';
              } else {
                line.parts.forEach(part => {
                  if (part.type === 'chord') {
                    htmlContent += `<span class="chord">${part.content}</span>`;
                  } else if (part.type === 'section') {
                    htmlContent += `<span class="section">${part.content}</span>`;
                  } else {
                    htmlContent += part.content.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                  }
                });
              }
              htmlContent += '</div>';
            });
            
            htmlContent += `</body></html>`;
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            printWindow.onload = () => { printWindow.print(); };
          };

          const exportToWord = () => {
            const formattedLines = formatContent(currentSong.content, transposition);
            let rtfContent = `{\\rtf1\\ansi\\ansicpg1252\\deff0\n{\\fonttbl{\\f0 Arial;}{\\f1 Courier New;}}\n{\\colortbl;\\red0\\green0\\blue0;\\red29\\green78\\blue216;}\n`;
            
            const escapeRTF = (text) => {
              return text.replace(/\\/g, '\\\\').replace(/{/g, '\\{').replace(/}/g, '\\}')
                .replace(//g, "\\'e1").replace(//g, "\\'e9").replace(//g, "\\'ed")
                .replace(//g, "\\'f3").replace(//g, "\\'fa").replace(//g, "\\'f1")
                .replace(//g, "\\'c1").replace(//g, "\\'c9").replace(//g, "\\'cd")
                .replace(//g, "\\'d3").replace(//g, "\\'da").replace(//g, "\\'d1")
                .replace(//g, "\\'fc").replace(//g, "\\'dc")
                .replace(//g, "\\'bf").replace(//g, "\\'a1");
            };
            
            rtfContent += `\\f0\\fs28\\b ${escapeRTF(currentSong.title)}\\b0\\par\\par\n\\fs20 `;
            if (transposition !== 0) {
              rtfContent += `Original: ${currentSong.originalKey}, Current: ${getCurrentKey()}\\par\n`;
            } else {
              rtfContent += `Key: ${currentSong.originalKey}\\par\n`;
            }
            if (currentSong.bpm) rtfContent += `BPM: ${currentSong.bpm}\\par\n`;
            if (currentSong.timeSignature) rtfContent += `Time: ${currentSong.timeSignature}\\par\n`;
            rtfContent += `\\par\n\\f1\\fs22 `;
            
            formattedLines.forEach(line => {
              if (line.isEmpty) {
                rtfContent += `\\par\n`;
              } else {
                line.parts.forEach(part => {
                  const cleanText = escapeRTF(part.content);
                  if (part.type === 'chord') {
                    rtfContent += `{\\b ${cleanText}}`;
                  } else if (part.type === 'section') {
                    rtfContent += `{\\b\\fs28\\cf2 ${cleanText}}\\par\n`;
                  } else {
                    rtfContent += cleanText;
                  }
                });
                rtfContent += `\\par\n`;
              }
            });
            
            rtfContent += `}`;
            const blob = new Blob([rtfContent], { type: 'application/rtf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentSong.title}.doc`;
            a.click();
            URL.revokeObjectURL(url);
          };

          const exportAllSongs = () => {
            setShowExportModal(true);
          };
          
          const exportSongs = (songsToExport, filename) => {
            if (songsToExport.length === 0) {
              alert('No songs to export!');
              return;
            }
            
            const dataStr = JSON.stringify(songsToExport, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            alert(`${songsToExport.length} songs exported!`);
            setShowExportModal(false);
          };
          
          const exportCurrentFolder = () => {
            if (selectedFolder === 'all') {
              exportSongs(songs, 'all-songs.tone');
            } else if (selectedFolder === 'uncategorized') {
              const uncategorizedSongs = songs.filter(s => !s.folders || s.folders.length === 0);
              exportSongs(uncategorizedSongs, 'uncategorized-songs.tone');
            } else {
              const folder = folders.find(f => f.id === selectedFolder);
              const folderSongs = songs.filter(s => s.folders && s.folders.includes(selectedFolder));
              const folderName = folder ? folder.name.replace(/[^a-z0-9]/gi, '-').toLowerCase() : 'folder';
              exportSongs(folderSongs, `${folderName}-songs.tone`);
            }
          };

          const importAllSongs = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const importedSongs = JSON.parse(e.target.result);
                if (Array.isArray(importedSongs)) {
                  // Store imported data and show folder selection modal
                  setImportedSongsData(importedSongs);
                  setShowImportFolderModal(true);
                } else {
                  alert('Invalid file format');
                }
              } catch (error) {
                alert('Error reading file');
              }
            };
            reader.readAsText(file);
            event.target.value = '';
          };

          const finishImportWithFolder = (folderId) => {
            if (!importedSongsData) return;
            
            // Auto-create folders from imported songs
            const importedFolderNames = new Set();
            importedSongsData.forEach(song => {
              if (song.folders && Array.isArray(song.folders)) {
                song.folders.forEach(folderRef => {
                  // If folderRef is a string (folder name), collect it
                  if (typeof folderRef === 'string' && folderRef.length > 0) {
                    importedFolderNames.add(folderRef);
                  }
                });
              }
            });
            
            // Create folders that don't exist
            const existingFolderNames = new Set(folders.map(f => f.name.toLowerCase()));
            const foldersToCreate = Array.from(importedFolderNames).filter(
              name => !existingFolderNames.has(name.toLowerCase())
            );
            
            let updatedFolders = [...folders];
            const folderNameToId = {};
            
            // Map existing folders
            folders.forEach(f => {
              folderNameToId[f.name.toLowerCase()] = f.id;
            });
            
            // Create new folders
            foldersToCreate.forEach(name => {
              const newFolder = {
                id: Date.now().toString() + Math.random(),
                name: name,
                createdAt: new Date().toISOString()
              };
              updatedFolders.push(newFolder);
              folderNameToId[name.toLowerCase()] = newFolder.id;
            });
            
            if (foldersToCreate.length > 0) {
              setFolders(updatedFolders);
              localStorage.setItem('chordTransposerFolders', JSON.stringify(updatedFolders));
            }
            
            // Check for duplicates
            const existingSongMap = new Map();
            songs.forEach(s => {
              existingSongMap.set(`${s.title}-${s.originalKey}`, s);
            });
            
            const duplicates = [];
            const newSongs = [];
            
            importedSongsData.forEach(importedSong => {
              const key = `${importedSong.title}-${importedSong.originalKey}`;
              if (existingSongMap.has(key)) {
                duplicates.push({
                  imported: importedSong,
                  existing: existingSongMap.get(key)
                });
              } else {
                newSongs.push(importedSong);
              }
            });
            
            if (duplicates.length > 0) {
              // Show duplicate handling modal
              setDuplicateSongs(duplicates);
              setSelectedFolderForImport(folderId);
              setShowImportFolderModal(false);
              setShowDuplicateModal(true);
            } else {
              // No duplicates, proceed with import
              finishImportNoDuplicates(newSongs, [], folderId, folderNameToId);
            }
          };

          const finishImportNoDuplicates = (newSongs, songsToReplace, folderId, folderNameToId) => {
            // Convert folder names to IDs in imported songs
            const processedSongs = [...newSongs, ...songsToReplace].map(s => {
              let folderIds = [];
              
              // Add the selected import folder if provided
              if (folderId) {
                folderIds.push(folderId);
              }
              
              // Convert folder names from imported song to IDs
              if (s.folders && Array.isArray(s.folders)) {
                s.folders.forEach(folderRef => {
                  if (typeof folderRef === 'string') {
                    const folderId = folderNameToId[folderRef.toLowerCase()];
                    if (folderId && !folderIds.includes(folderId)) {
                      folderIds.push(folderId);
                    }
                  } else {
                    // Already an ID
                    if (!folderIds.includes(folderRef)) {
                      folderIds.push(folderRef);
                    }
                  }
                });
              }
              
              return {
                ...s,
                folders: folderIds
              };
            });
            
            // Remove songs that are being replaced
            const replaceKeys = new Set(songsToReplace.map(s => `${s.title}-${s.originalKey}`));
            const filteredExisting = songs.filter(s => {
              const key = `${s.title}-${s.originalKey}`;
              return !replaceKeys.has(key);
            });
            
            const mergedSongs = [...filteredExisting, ...processedSongs];
            setSongs(mergedSongs);
            localStorage.setItem('chordTransposerSongs', JSON.stringify(mergedSongs));
            
            const replaced = songsToReplace.length;
            const added = newSongs.length;
            
            let message = '';
            if (added > 0 && replaced > 0) {
              message = `Added ${added} new songs, Replaced ${replaced} existing songs`;
            } else if (added > 0) {
              message = `Successfully added ${added} songs!`;
            } else if (replaced > 0) {
              message = `Replaced ${replaced} songs`;
            }
            
            if (message) alert(message);
            
            setImportedSongsData(null);
            setShowImportFolderModal(false);
            setImportFolderName('');
            setShowDuplicateModal(false);
            setDuplicateSongs([]);
            setSelectedFolderForImport(null);
          };

          const handleDuplicateDecision = (replaceAll) => {
            if (!importedSongsData) return;
            
            // Get folder name to ID mapping
            const folderNameToId = {};
            folders.forEach(f => {
              folderNameToId[f.name.toLowerCase()] = f.id;
            });
            
            const existingSongMap = new Map();
            songs.forEach(s => {
              existingSongMap.set(`${s.title}-${s.originalKey}`, s);
            });
            
            const newSongs = [];
            const songsToReplace = [];
            
            importedSongsData.forEach(importedSong => {
              const key = `${importedSong.title}-${importedSong.originalKey}`;
              if (existingSongMap.has(key)) {
                if (replaceAll) {
                  songsToReplace.push(importedSong);
                }
                // If not replacing, skip this song
              } else {
                newSongs.push(importedSong);
              }
            });
            
            finishImportNoDuplicates(newSongs, songsToReplace, selectedFolderForImport, folderNameToId);
          };

          const createFolderAndImport = () => {
            if (!importFolderName.trim()) {
              alert('Please enter a folder name');
              return;
            }
            
            // Create new folder
            const folder = {
              id: Date.now().toString(),
              name: importFolderName.trim(),
              createdAt: new Date().toISOString()
            };
            
            const updatedFolders = [...folders, folder];
            setFolders(updatedFolders);
            localStorage.setItem('chordTransposerFolders', JSON.stringify(updatedFolders));
            
            // Import with new folder
            finishImportWithFolder(folder.id);
          };

          const filteredSongs = songs
            .filter(song => {
              // Filter by search query
              const matchesSearch = song.title.toLowerCase().includes(searchQuery.toLowerCase()) || 
                                   song.originalKey.toLowerCase().includes(searchQuery.toLowerCase());
              if (!matchesSearch) return false;
              
              // Filter by selected folder
              if (selectedFolder === 'all') return true;
              if (selectedFolder === 'uncategorized') return !song.folders || song.folders.length === 0;
              return song.folders && song.folders.includes(selectedFolder);
            })
            .sort((a, b) => {
              if (a.pinned && !b.pinned) return -1;
              if (!a.pinned && b.pinned) return 1;
              return 0;
            });

          return (
            <div className="flex h-screen bg-gray-50">
              {/* Mobile Menu Backdrop */}
              <div 
                className={`mobile-backdrop ${mobileMenuOpen ? 'show' : ''}`}
                onClick={() => setMobileMenuOpen(false)}
              />
              
              {showImportModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg p-6 max-w-2xl w-full mx-4">
                    <h2 className="text-xl font-bold mb-4">Import from Text</h2>
                    <p className="text-sm text-gray-600 mb-4">Paste chord text from any website. The app will try to convert it to the correct format.</p>
                    <textarea value={importText} onChange={(e) => setImportText(e.target.value)}
                      className="w-full h-64 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm"
                      placeholder="Paste your chord text here..." />
                    <div className="flex gap-2 mt-4">
                      <button onClick={parseImportedText} className="flex items-center gap-2 bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700">Import</button>
                      <button onClick={() => { setShowImportModal(false); setImportText(''); }}
                        className="flex items-center gap-2 bg-gray-300 text-gray-700 px-6 py-2 rounded-lg hover:bg-gray-400">Cancel</button>
                    </div>
                  </div>
                </div>
              )}
              
              {showNewFolderModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <h2 className="text-xl font-bold mb-4">New Folder</h2>
                    <input 
                      type="text" 
                      value={newFolderName}
                      onChange={(e) => setNewFolderName(e.target.value)}
                      onKeyPress={(e) => e.key === 'Enter' && createFolder()}
                      placeholder="Folder name..."
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      autoFocus
                    />
                    <div className="flex gap-2 mt-4">
                      <button onClick={createFolder} className="flex items-center gap-2 bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700">
                        <FolderPlus size={18} />Create
                      </button>
                      <button onClick={() => { setShowNewFolderModal(false); setNewFolderName(''); }}
                        className="flex items-center gap-2 bg-gray-300 text-gray-700 px-6 py-2 rounded-lg hover:bg-gray-400">Cancel</button>
                    </div>
                  </div>
                </div>
              )}
              
              {showMoveSongModal && songToMove && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <h2 className="text-xl font-bold mb-4">Add "{songToMove.title}" to Folders</h2>
                    <div className="space-y-2 max-h-96 overflow-y-auto">
                      {folders.length === 0 ? (
                        <p className="text-gray-500 text-sm text-center py-4">No folders yet. Create one first!</p>
                      ) : (
                        folders.map(folder => {
                          const isInFolder = songToMove.folders && songToMove.folders.includes(folder.id);
                          return (
                            <div key={folder.id} className="flex items-center justify-between p-3 border rounded-lg hover:bg-gray-50">
                              <div className="flex items-center gap-2">
                                <Folder size={16} />
                                <span>{folder.name}</span>
                              </div>
                              {isInFolder ? (
                                <button 
                                  onClick={() => removeSongFromFolder(songToMove.id, folder.id)}
                                  className="text-red-600 hover:text-red-700 text-sm">
                                  Remove
                                </button>
                              ) : (
                                <button 
                                  onClick={() => addSongToFolder(songToMove.id, folder.id)}
                                  className="text-blue-600 hover:text-blue-700 text-sm">
                                  Add
                                </button>
                              )}
                            </div>
                          );
                        })
                      )}
                    </div>
                    <div className="flex gap-2 mt-4">
                      <button onClick={() => { setShowMoveSongModal(false); setSongToMove(null); }}
                        className="flex-1 bg-gray-300 text-gray-700 px-6 py-2 rounded-lg hover:bg-gray-400">Done</button>
                    </div>
                  </div>
                </div>
              )}
              
              {showImportFolderModal && importedSongsData && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <h2 className="text-xl font-bold mb-4">Import {importedSongsData.length} Songs</h2>
                    <p className="text-sm text-gray-600 mb-4">Add these songs to a folder?</p>
                    
                    <div className="space-y-2 max-h-64 overflow-y-auto mb-4">
                      <div 
                        onClick={() => finishImportWithFolder(null)}
                        className="p-3 border rounded-lg hover:bg-gray-50 cursor-pointer">
                        <div className="flex items-center gap-2">
                          <FileText size={16} />
                          <span>No folder (Uncategorized)</span>
                        </div>
                      </div>
                      
                      {folders.map(folder => (
                        <div 
                          key={folder.id}
                          onClick={() => finishImportWithFolder(folder.id)}
                          className="p-3 border rounded-lg hover:bg-gray-50 cursor-pointer">
                          <div className="flex items-center gap-2">
                            <Folder size={16} />
                            <span>{folder.name}</span>
                          </div>
                        </div>
                      ))}
                    </div>
                    
                    <div className="border-t pt-4">
                      <p className="text-sm font-medium text-gray-700 mb-2">Or create new folder:</p>
                      <div className="flex gap-2">
                        <input 
                          type="text" 
                          value={importFolderName}
                          onChange={(e) => setImportFolderName(e.target.value)}
                          onKeyPress={(e) => e.key === 'Enter' && createFolderAndImport()}
                          placeholder="New folder name..."
                          className="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        />
                        <button 
                          onClick={createFolderAndImport}
                          className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">
                          Create & Import
                        </button>
                      </div>
                    </div>
                    
                    <div className="flex gap-2 mt-4">
                      <button onClick={() => { setShowImportFolderModal(false); setImportedSongsData(null); setImportFolderName(''); }}
                        className="flex-1 bg-gray-300 text-gray-700 px-6 py-2 rounded-lg hover:bg-gray-400">Cancel</button>
                    </div>
                  </div>
                </div>
              )}
              
              {showDuplicateModal && duplicateSongs.length > 0 && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg p-6 max-w-lg w-full mx-4">
                    <h2 className="text-xl font-bold mb-4">Duplicate Songs Found</h2>
                    <p className="text-sm text-gray-600 mb-4">
                      Found {duplicateSongs.length} song(s) that already exist in your library.
                    </p>
                    
                    <div className="bg-gray-50 rounded p-4 mb-4 max-h-48 overflow-y-auto">
                      <p className="text-sm font-medium mb-2">Duplicates:</p>
                      {duplicateSongs.slice(0, 5).map((dup, idx) => (
                        <p key={idx} className="text-sm text-gray-700"> {dup.imported.title} ({dup.imported.originalKey})</p>
                      ))}
                      {duplicateSongs.length > 5 && (
                        <p className="text-sm text-gray-500 mt-1">...and {duplicateSongs.length - 5} more</p>
                      )}
                    </div>
                    
                    <p className="text-sm text-gray-700 mb-4">What would you like to do?</p>
                    
                    <div className="space-y-2">
                      <button 
                        onClick={() => handleDuplicateDecision(true)}
                        className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 text-left">
                        <div className="font-medium">Replace Existing Songs</div>
                        <div className="text-sm text-blue-100">Update with imported versions (newer content)</div>
                      </button>
                      
                      <button 
                        onClick={() => handleDuplicateDecision(false)}
                        className="w-full bg-gray-600 text-white px-6 py-3 rounded-lg hover:bg-gray-700 text-left">
                        <div className="font-medium">Keep Existing Songs</div>
                        <div className="text-sm text-gray-200">Skip duplicates, only add new songs</div>
                      </button>
                      
                      <button 
                        onClick={() => {
                          setShowDuplicateModal(false);
                          setDuplicateSongs([]);
                          setImportedSongsData(null);
                          setSelectedFolderForImport(null);
                        }}
                        className="w-full bg-gray-300 text-gray-700 px-6 py-2 rounded-lg hover:bg-gray-400">
                        Cancel Import
                      </button>
                    </div>
                  </div>
                </div>
              )}
              
              {showExportModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                    <h2 className="text-xl font-bold mb-4">Export Songs</h2>
                    <p className="text-sm text-gray-600 mb-4">Choose what to export:</p>
                    
                    <div className="space-y-2">
                      <button 
                        onClick={() => exportSongs(songs, 'all-songs.tone')}
                        className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 text-left">
                        <div className="font-medium">Export All Songs</div>
                        <div className="text-sm text-blue-100">{songs.length} songs in your library</div>
                      </button>
                      
                      {selectedFolder !== 'all' && (
                        <button 
                          onClick={exportCurrentFolder}
                          className="w-full bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 text-left">
                          <div className="font-medium">Export Current Folder</div>
                          <div className="text-sm text-green-100">
                            {selectedFolder === 'uncategorized' 
                              ? `${songs.filter(s => !s.folders || s.folders.length === 0).length} uncategorized songs`
                              : `"${folders.find(f => f.id === selectedFolder)?.name}" - ${songs.filter(s => s.folders && s.folders.includes(selectedFolder)).length} songs`
                            }
                          </div>
                        </button>
                      )}
                      
                      <button 
                        onClick={() => setShowExportModal(false)}
                        className="w-full bg-gray-300 text-gray-700 px-6 py-2 rounded-lg hover:bg-gray-400">
                        Cancel
                      </button>
                    </div>
                    
                    <div className="mt-4 p-3 bg-blue-50 rounded-lg">
                      <p className="text-xs text-blue-800">
                         Tip: Export specific folders to share setlists with your band or backup categories separately!
                      </p>
                    </div>
                  </div>
                </div>
              )}

              
          {viewMode && metronomeActive && !menuVisible && (
            <div className="fixed top-20 right-4 z-50 bg-black bg-opacity-70 rounded p-2 text-white text-sm flex gap-2 items-center">
              <span>{metronomeBpm}</span>
              {[...Array(4)].map((_, i) => <div key={i} className={`w-2 h-2 rounded-full ${i === currentBeat - 1 ? 'bg-green-400' : 'bg-gray-500'}`} />)}
            </div>
          )}
          {viewMode ? (
                <div className="flex-1 flex flex-col bg-white">
                  <div className={`fixed top-0 left-0 right-0 z-50 bg-gray-800 text-white p-4 transition-all duration-300 ${menuVisible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-full pointer-events-none'}`}>
                    <div className="max-w-4xl mx-auto flex items-center justify-between performance-header-mobile">
                      <div className="song-info-mobile">
                        <h2 className="text-2xl font-bold">{currentSong.title}</h2>
                        <div className="text-sm text-gray-300 mt-1">
                          {transposition !== 0 ? (<span>Original: {currentSong.originalKey}, Current: {getCurrentKey()}</span>) : 
                           (<span>Key: {currentSong.originalKey}</span>)}
                          {currentSong.bpm && <span>  {currentSong.bpm} BPM</span>}
                          {currentSong.timeSignature && <span>  {currentSong.timeSignature}</span>}
                        </div>
                      </div>
                      <div className="flex gap-2 items-center flex-wrap">
                        {/* Previous/Next Song buttons - navigate through pinned songs */}
                        {(() => {
                          const pinnedSongs = songs.filter(s => s.pinned);
                          const hasPinnedSongs = pinnedSongs.length > 0;
                          const currentIndex = pinnedSongs.findIndex(s => s.id === currentSong?.id);
                          const isInPinnedList = currentIndex !== -1;
                          
                          return hasPinnedSongs && isInPinnedList && (
                            <>
                              <button 
                                onClick={goToPreviousSong}
                                className="flex items-center justify-center bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 text-sm"
                                title="Previous song">
                                
                              </button>
                              <span className="text-sm text-gray-600 px-2">
                                {currentIndex + 1}/{pinnedSongs.length}
                              </span>
                              <button 
                                onClick={goToNextSong}
                                className="flex items-center justify-center bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 text-sm"
                                title="Next song">
                                
                              </button>
                            </>
                          );
                        })()}
                        
                        <button onClick={() => {
                          if (!showLiveMode) {
                            // Entering Live Mode - reset to first section
                            setLiveSectionIndex(0);
                            setLiveProgress(0);
                            setLiveIsPlaying(false);
                            setMetronomeActive(true); // Turn ON for Live Mode
                          } else {
                            // Exiting Live Mode
                            setLiveIsPlaying(false);
                            setLiveProgress(0);
                            setMetronomeActive(false);
                            if (window.liveTimer) {
                              clearInterval(window.liveTimer);
                              window.liveTimer = null;
                            }
                          }
                          setShowLiveMode(!showLiveMode);
                        }} className={`flex items-center gap-1 px-3 py-2 rounded-lg whitespace-nowrap ${showLiveMode ? 'bg-red-600 text-white' : 'bg-red-100 text-red-700'}`}>
                          <span className="flex items-center gap-1 font-bold text-xs"><span className="w-2 h-2 bg-red-600 rounded-full animate-pulse"></span>LIVE</span>
                        </button>
                        <button onClick={() => setViewMode(false)} className="flex items-center gap-1 bg-white text-gray-800 px-3 py-2 rounded-lg hover:bg-gray-100 whitespace-nowrap">
                          <X size={18} /><span className="hidden sm:inline">Exit Performance</span><span className="sm:hidden">Exit</span>
                        </button>
                      </div>
                    </div>
                  </div>

                  <div className={`fixed top-0 left-0 right-0 z-40 bg-gray-100 border-b border-gray-200 p-3 transition-all duration-300 ${menuVisible ? 'opacity-100' : 'opacity-0 -translate-y-full pointer-events-none'}`} style={{top: menuVisible ? '80px' : '0'}}>
                    <div className="max-w-4xl mx-auto">
                      {/* Row 1: Display mode buttons */}
                      <div className="flex flex-wrap items-center gap-2 mb-3">
                        <button onClick={() => setViewDisplayMode('chords')}
                          className={`px-4 py-2 rounded-lg text-sm font-medium ${viewDisplayMode === 'chords' ? 'bg-blue-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}`}>
                          Show Chords
                        </button>
                        <button onClick={() => setViewDisplayMode('lyrics')}
                          className={`px-4 py-2 rounded-lg text-sm font-medium ${viewDisplayMode === 'lyrics' ? 'bg-blue-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}`}>
                          Lyrics Only
                        </button>
                        <button onClick={() => setViewDisplayMode('numbers')}
                          className={`px-4 py-2 rounded-lg text-sm font-medium ${viewDisplayMode === 'numbers' ? 'bg-blue-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}`}>
                          Show Numbers
                        </button>
                        <button onClick={() => setColumnLayout(columnLayout === 1 ? 2 : 1)}
                          className="flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium bg-white text-gray-700 hover:bg-gray-50"
                          title="Toggle columns">
                          <Columns size={18} />{columnLayout} Col
                        </button>
                        
                        {/* Transpose controls - inline on desktop, wrapped on mobile */}
                        {viewDisplayMode === 'chords' && (
                          <div className="flex items-center gap-2 ml-auto">
                            <span className="text-sm font-medium text-gray-700">Transpose:</span>
                            <button onClick={() => setTransposition(t => t - 1)} className="w-10 h-10 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-bold">-</button>
                            <span className="w-16 text-center font-medium">{transposition > 0 ? '+' : ''}{transposition}</span>
                            <button onClick={() => setTransposition(t => t + 1)} className="w-10 h-10 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-bold">+</button>
                            {transposition !== 0 && (
                              <button onClick={() => setTransposition(0)} className="ml-2 px-3 py-1 text-sm bg-gray-300 text-gray-700 rounded hover:bg-gray-400">Reset</button>
                            )}
                          </div>
                        )}
                      </div>
                      
                      {/* Row 2: Metronome, BPM, and Font controls */}
                      <div className="flex flex-wrap items-center gap-4 pt-3 border-t border-gray-200">
                        <div className="flex items-center gap-2">
                          <span className="text-sm font-medium text-gray-700">Metronome:</span>
                          <button 
                            onClick={toggleMetronome}
                            className={`px-4 py-2 rounded-lg text-sm font-medium ${metronomeActive ? 'bg-green-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}`}>
                            {metronomeActive ? ' Stop' : ' Play'}
                          </button>
                          {metronomeActive && (
                            <div className="flex items-center gap-1">
                              {[...Array(parseInt(currentSong?.timeSignature?.match(/^(\d+)/)?.[1] || 4))].map((_, i) => (
                                <div key={i} className={`w-3 h-3 rounded-full ${i === currentBeat - 1 ? 'bg-green-500' : 'bg-gray-300'}`}></div>
                              ))}
                            </div>
                          )}
                        </div>
                        
                        <div className="flex items-center gap-2">
                          <span className="text-sm font-medium text-gray-700">BPM:</span>
                          <button onClick={() => adjustMetronomeBpm(-5)} className="w-10 h-10 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-bold">-</button>
                          <span className="w-16 text-center font-medium">{metronomeBpm}</span>
                          <button onClick={() => adjustMetronomeBpm(5)} className="w-10 h-10 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-bold">+</button>
                        </div>
                        
                        <div className="flex items-center gap-2">
                          <span className="text-sm font-medium text-gray-700">Font:</span>
                          <button onClick={() => setPerformanceFontSize(Math.max(50, performanceFontSize - 10))} className="w-10 h-10 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-bold">-</button>
                          <span className="w-16 text-center font-medium text-sm">{performanceFontSize}%</span>
                          <button onClick={() => setPerformanceFontSize(Math.min(200, performanceFontSize + 10))} className="w-10 h-10 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-bold">+</button>
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Permanent Song Info - Visible when menu is hidden */}
                  {!menuVisible && (
                    <div className="fixed top-4 right-4 z-40 bg-gray-800 text-white px-4 py-3 rounded-lg shadow-lg">
                      <div className="text-sm font-bold">{currentSong.title}</div>
                      <div className="text-xs text-gray-300 mt-1 flex items-center gap-2">
                        <span>Key: {getCurrentKey()}</span>
                        {currentSong.bpm && <span> {currentSong.bpm} BPM</span>}
                      </div>
                    </div>
                  )}

                  <div className={`flex-1 overflow-y-auto p-8 transition-all duration-300 ${menuVisible ? 'mt-48' : 'mt-0'}`}>
                    {showLiveMode ? (
                      <div className="fixed inset-0 z-50 bg-white flex flex-col" onClick={() => {
                        // Click anywhere to toggle controls visibility when playing
                        if (liveIsPlaying) {
                          setMenuVisible(!menuVisible);
                        }
                      }}>
                        {/* Live Mode Content */}
                        <div className="h-full flex flex-col relative">
                        {(() => {
                          const sections = parseLiveSections(currentSong?.content || '');
                          
                          if (sections.length === 0) {
                            return (
                              <div className="flex-1 flex items-center justify-center">
                                <div className="text-center text-gray-500">
                                  <p className="text-xl mb-2">No sections found</p>
                                  <p className="text-sm">Format: [INTRO x2]<br/>//8 measures</p>
                                </div>
                              </div>
                            );
                          }
                          
                          const section = sections[liveSectionIndex] || sections[0];
                          const bpm = parseInt(currentSong?.bpm) || metronomeBpm || 120;
                          const duration = calculateSectionDuration(section.measures, bpm, currentSong?.timeSignature || '4/4', section.repeat);
                          const nextSection = sections[liveSectionIndex + 1];
                          
                          return (
                            <>
                              {/* Header - Auto-hide when playing, absolutely positioned */}
                              <div className={`absolute top-0 left-0 right-0 bg-gray-900 text-white p-2 md:p-3 live-controls transition-transform duration-300 ${liveIsPlaying && !menuVisible ? '-translate-y-full' : 'translate-y-0'}`} style={{zIndex: 10}}>
                                {/* Song Title and Info */}
                                <div className="mb-2 pb-2 border-b border-gray-700">
                                  <h2 className="text-base md:text-lg font-bold">{currentSong.title}</h2>
                                  <div className="text-xs text-gray-400 mt-1">
                                    Key: {currentSong.originalKey}
                                    {currentSong.bpm && <span>  {currentSong.bpm} BPM</span>}
                                    {currentSong.timeSignature && <span>  {currentSong.timeSignature}</span>}
                                  </div>
                                </div>
                                
                                {/* Mobile: Two rows, Desktop: Single row */}
                                <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
                                  {/* Row 1 (mobile) / Left (desktop): Font and Metronome Controls */}
                                  <div className="flex items-center justify-between md:justify-start gap-2 flex-wrap live-font-controls">
                                    <div className="flex items-center gap-2">
                                      <span className="text-xs text-gray-400">Font:</span>
                                      <button onClick={() => setLiveFontSize(Math.max(50, liveFontSize - 10))} className="w-6 h-6 bg-gray-700 rounded hover:bg-gray-600 text-xs flex items-center justify-center">-</button>
                                      <span className="text-xs w-12 text-center">{liveFontSize}%</span>
                                      <button onClick={() => setLiveFontSize(Math.min(200, liveFontSize + 10))} className="w-6 h-6 bg-gray-700 rounded hover:bg-gray-600 text-xs flex items-center justify-center">+</button>
                                    </div>
                                    
                                    <div className="flex items-center gap-2">
                                      <button 
                                        onClick={() => setMetronomeActive(!metronomeActive)}
                                        className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-medium ${metronomeActive ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-700 hover:bg-gray-600'}`}
                                        title={metronomeActive ? 'Turn metronome OFF' : 'Turn metronome ON'}>
                                         {metronomeActive ? 'ON' : 'OFF'}
                                      </button>
                                      
                                      {metronomeActive && (
                                        <button 
                                          onClick={() => setMetronomeAudioMuted(!metronomeAudioMuted)}
                                          className={`w-8 h-8 flex items-center justify-center rounded text-sm ${metronomeAudioMuted ? 'bg-red-600 hover:bg-red-700' : 'bg-gray-700 hover:bg-gray-600'}`}
                                          title={metronomeAudioMuted ? 'Unmute metronome' : 'Mute metronome'}>
                                          {metronomeAudioMuted ? '' : ''}
                                        </button>
                                      )}
                                    </div>
                                    
                                    {/* Previous/Next Song buttons */}
                                    {(() => {
                                      const pinnedSongs = songs.filter(s => s.pinned);
                                      const hasPinnedSongs = pinnedSongs.length > 0;
                                      const currentIndex = pinnedSongs.findIndex(s => s.id === currentSong?.id);
                                      const isInPinnedList = currentIndex !== -1;
                                      
                                      return hasPinnedSongs && isInPinnedList && (
                                        <div className="flex items-center gap-2">
                                          <button 
                                            onClick={goToPreviousSong}
                                            className="flex items-center gap-1 bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700 text-xs"
                                            title="Previous song">
                                            
                                          </button>
                                          <span className="text-xs text-gray-400">
                                            {currentIndex + 1}/{pinnedSongs.length}
                                          </span>
                                          <button 
                                            onClick={goToNextSong}
                                            className="flex items-center gap-1 bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700 text-xs"
                                            title="Next song">
                                            
                                          </button>
                                        </div>
                                      );
                                    })()}
                                    
                                    {/* Exit button - visible on mobile in row 1 */}
                                    <button 
                                      onClick={() => {
                                        setLiveIsPlaying(false);
                                        setLiveProgress(0);
                                        setMetronomeActive(false);
                                        if (window.liveTimer) {
                                          clearInterval(window.liveTimer);
                                          window.liveTimer = null;
                                        }
                                        setShowLiveMode(false);
                                      }}
                                      className="md:hidden bg-red-600 text-white px-3 py-1 rounded-lg hover:bg-red-700 flex items-center gap-1 text-xs ml-auto">
                                      <X size={16} />Exit
                                    </button>
                                  </div>
                                  
                                  {/* Desktop only: Exit button on right */}
                                  <button 
                                    onClick={() => {
                                      setLiveIsPlaying(false);
                                      setLiveProgress(0);
                                      setMetronomeActive(false);
                                      if (window.liveTimer) {
                                        clearInterval(window.liveTimer);
                                        window.liveTimer = null;
                                      }
                                      setShowLiveMode(false);
                                    }}
                                    className="hidden md:flex bg-red-600 text-white px-3 py-2 rounded-lg hover:bg-red-700 items-center gap-1 text-sm">
                                    <X size={18} />Exit Live
                                  </button>
                                </div>
                              </div>
                              
                              {/* Transport Controls - Floating at bottom center */}
                              <div className={`fixed bottom-20 left-1/2 transform -translate-x-1/2 z-20 transition-all duration-300 ${liveIsPlaying && !menuVisible ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                                <div className="flex items-center justify-center gap-2 bg-gray-900/90 backdrop-blur-sm px-4 py-3 rounded-full shadow-lg">
                                  <button 
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      if (liveSectionIndex > 0) {
                                        setLiveSectionIndex(liveSectionIndex - 1);
                                        setLiveProgress(0);
                                        setLiveIsPlaying(false);
                                      }
                                    }}
                                    disabled={liveSectionIndex === 0}
                                    className="w-10 h-10 md:w-12 md:h-12 bg-gray-700 text-white rounded-full hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed text-lg md:text-xl flex items-center justify-center">
                                    
                                  </button>
                                  
                                  <button 
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      setLiveIsPlaying(!liveIsPlaying);
                                    }}
                                    className="w-12 h-12 md:w-16 md:h-16 bg-green-600 text-white rounded-full hover:bg-green-700 text-xl md:text-2xl flex items-center justify-center shadow-lg">
                                    {liveIsPlaying ? '' : ''}
                                  </button>
                                  
                                  <button 
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      if (liveSectionIndex < sections.length - 1) {
                                        setLiveSectionIndex(liveSectionIndex + 1);
                                        setLiveProgress(0);
                                        setLiveIsPlaying(false);
                                      }
                                    }}
                                    disabled={liveSectionIndex >= sections.length - 1}
                                    className="w-10 h-10 md:w-12 md:h-12 bg-gray-700 text-white rounded-full hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed text-lg md:text-xl flex items-center justify-center">
                                    
                                  </button>
                                </div>
                              </div>
                              
                              <div className="bg-gray-300 h-2 shrink-0">
                                <div className="bg-green-500 h-full transition-all duration-300" style={{width: liveProgress + '%'}} />
                              </div>
                              
                              <div className={`flex-1 overflow-y-auto p-6 pb-6 flex justify-center transition-all duration-300 ${liveIsPlaying && !menuVisible ? 'pt-4' : 'pt-24 md:pt-28'}`}>
                                <div className="max-w-4xl w-full flex flex-col items-center">
                                  <div className="text-center mb-6">
                                    <h1 className="text-5xl md:text-6xl font-bold text-blue-700 mb-2">{section.name}</h1>
                                    {liveIsPlaying && metronomeActive && (
                                      <div className="flex justify-center gap-2 mb-2">
                                        {Array.from({ length: parseInt((currentSong?.timeSignature || '4/4').split('/')[0]) }).map((_, i) => (
                                          <div key={i} className={`w-3 h-3 rounded-full ${i === metronomeBeat ? 'bg-green-600' : 'bg-gray-400'}`} />
                                        ))}
                                      </div>
                                    )}
                                    <p className="text-lg md:text-xl text-gray-600">
                                      {section.measures * section.repeat} {(section.measures * section.repeat) === 1 ? 'measure' : 'measures'}
                                      {section.repeat > 1 ? ' (' + section.measures + '  ' + section.repeat + ')' : ''}
                                      {'  ' + Math.round(duration) + 's'}
                                    </p>
                                  </div>
                                  
                                  <div style={{fontSize: liveFontSize + '%'}} className={`font-mono whitespace-pre-wrap text-left ${(() => {
                                      const lines = section.content.length;
                                      const chars = section.content.join('\n').length;
                                      // More aggressive sizing for long content
                                      if (lines > 24 || chars > 800) return 'text-xs md:text-sm';
                                      if (lines > 18 || chars > 600) return 'text-sm md:text-base';
                                      if (lines > 12 || chars > 400) return 'text-base md:text-lg';  
                                      if (lines > 8 || chars > 250) return 'text-lg md:text-xl';
                                      return 'text-xl md:text-2xl';
                                    })()}`}>
                                    {formatContent(section.content.join('\n'), transposition, viewDisplayMode, currentSong.originalKey).map((line, i) => (
                                      <div key={i} className="leading-relaxed mb-1">
                                        {line.isEmpty ? <br /> : line.parts.map((part, j) => (
                                          <span key={j} className={part.type === 'chord' ? 'font-bold text-black' : part.type === 'section' ? 'hidden' : ''}>
                                            {part.content}
                                          </span>
                                        ))}
                                      </div>
                                    ))}
                                  </div>
                                </div>
                              </div>
                              
                              {nextSection && (
                                <div className="bg-gray-100 p-3 text-center border-t-2 border-gray-300 shrink-0">
                                  <p className="text-gray-700 text-lg">
                                    <span className="font-semibold">Next:</span> {nextSection.name}
                                    {nextSection.repeat > 1 ? ' (' + nextSection.repeat + ')' : ''}
                                  </p>
                                </div>
                              )}
                            </>
                          );
                        })()}
                        </div>
                      </div>
                    ) : columnLayout === 2 ? (
                      <div className="max-w-7xl mx-auto grid grid-cols-2 gap-8 font-mono" style={{fontSize: `${performanceFontSize}%`}}>
                        {(() => {
                          // Filter out //measures lines from display
                          const formattedLines = formatContent(filterMeasureLines(currentSong.content), transposition, viewDisplayMode, currentSong.originalKey);
                          const sections = [];
                          let currentSection = [];
                          
                          // Group lines into sections
                          formattedLines.forEach((line, i) => {
                            const isSection = line.parts.some(p => p.type === 'section');
                            if (isSection && currentSection.length > 0) {
                              sections.push(currentSection);
                              currentSection = [line];
                            } else {
                              currentSection.push(line);
                            }
                          });
                          if (currentSection.length > 0) sections.push(currentSection);
                          
                          // Balance sections by CHARACTER COUNT for more visual balance
                          // Calculate total characters in each section
                          const sectionsWithWeights = sections.map(section => {
                            const charCount = section.reduce((sum, line) => {
                              const lineText = line.parts.map(p => p.content).join('');
                              // Weight section headers more (they're visually larger)
                              const isSection = line.parts.some(p => p.type === 'section');
                              return sum + lineText.length * (isSection ? 1.5 : 1);
                            }, 0);
                            return { section, weight: charCount };
                          });
                          
                          const totalWeight = sectionsWithWeights.reduce((sum, s) => sum + s.weight, 0);
                          const targetWeight = totalWeight / 2;
                          
                          const leftSections = [];
                          const rightSections = [];
                          let leftWeight = 0;
                          
                          sectionsWithWeights.forEach(({ section, weight }) => {
                            if (leftWeight < targetWeight) {
                              leftSections.push(section);
                              leftWeight += weight;
                            } else {
                              rightSections.push(section);
                            }
                          });
                          
                          return (
                            <>
                              <div className="whitespace-pre-wrap">
                                {leftSections.map((section, sIdx) => (
                                  <div key={`left-${sIdx}`}>
                                    {section.map((line, i) => (
                                      <div key={i} className="leading-relaxed mb-1">
                                        {line.isEmpty ? (<br />) : (
                                          line.parts.map((part, j) => (
                                            <span key={j} className={part.type === 'chord' ? 'font-bold text-black' : 
                                              part.type === 'section' ? 'block font-bold text-blue-700 mt-4 mb-2' : ''} style={part.type === 'section' ? {fontSize: '1.3em'} : {}}>
                                              {part.content}
                                            </span>
                                          ))
                                        )}
                                      </div>
                                    ))}
                                  </div>
                                ))}
                              </div>
                              <div className="whitespace-pre-wrap">
                                {rightSections.map((section, sIdx) => (
                                  <div key={`right-${sIdx}`}>
                                    {section.map((line, i) => (
                                      <div key={i} className="leading-relaxed mb-1">
                                        {line.isEmpty ? (<br />) : (
                                          line.parts.map((part, j) => (
                                            <span key={j} className={part.type === 'chord' ? 'font-bold text-black' : 
                                              part.type === 'section' ? 'block font-bold text-blue-700 mt-4 mb-2' : ''} style={part.type === 'section' ? {fontSize: '1.3em'} : {}}>
                                              {part.content}
                                            </span>
                                          ))
                                        )}
                                      </div>
                                    ))}
                                  </div>
                                ))}
                              </div>
                            </>
                          );
                        })()}
                      </div>
                    ) : (
                      <div className="max-w-4xl mx-auto font-mono whitespace-pre-wrap" style={{fontSize: `${performanceFontSize}%`}}>
                        {formatContent(filterMeasureLines(currentSong.content), transposition, viewDisplayMode, currentSong.originalKey).map((line, i) => (
                          <div key={i} className="leading-relaxed mb-1">
                            {line.isEmpty ? (<br />) : (
                              line.parts.map((part, j) => (
                                <span key={j} className={part.type === 'chord' ? 'font-bold text-black' : 
                                  part.type === 'section' ? 'block font-bold text-blue-700 mt-4 mb-2' : ''} style={part.type === 'section' ? {fontSize: '1.3em'} : {}}>
                                  {part.content}
                                </span>
                              ))
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              ) : (
                <>
                  {/* Sidebar - Responsive: desktop always visible, mobile hidden until hamburger clicked */}
                  <div className={`sidebar-container w-80 bg-white border-r border-gray-200 flex-col md:flex ${mobileMenuOpen ? 'mobile-open flex' : 'hidden md:flex'}`}>
                    <div className="p-4 border-b border-gray-200">
                      <div className="flex items-center justify-between mb-4">
                        <div className="flex items-center gap-2">
                          <Music className="text-blue-600" size={24} />
                          <h1 className="text-xl font-bold">Song Library</h1>
                        </div>
                        {/* Close button - only visible on mobile */}
                        <button 
                          onClick={() => setMobileMenuOpen(false)}
                          className="md:hidden p-2 hover:bg-gray-100 rounded-lg text-gray-600"
                          aria-label="Close menu"
                        >
                          <X size={24} />
                        </button>
                      </div>
                      <button onClick={startNewSong} className="w-full flex items-center justify-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">
                        <Plus size={20} />New Song
                      </button>
                      
                      <div className="mt-4 space-y-2">
                        <button onClick={exportAllSongs} className="w-full flex items-center justify-center gap-2 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 text-sm">
                          <Download size={18} />Export All Songs
                        </button>
                        <label className="w-full flex items-center justify-center gap-2 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 cursor-pointer text-sm">
                          <input type="file" accept=".tone" onChange={importAllSongs} className="hidden" />
                          <Plus size={18} />Import Songs
                        </label>
                      </div>
                    </div>
                    
                    <div className="p-4 border-b border-gray-200">
                      <input type="text" placeholder="Search songs..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" />
                    </div>
                    
                    <div className="flex-1 overflow-y-auto p-4">
                      <div className="mb-4">
                        <div className="flex items-center justify-between mb-2">
                          <h3 className="text-sm font-semibold text-gray-700">FOLDERS</h3>
                          <button onClick={() => setShowNewFolderModal(true)} className="text-blue-600 hover:text-blue-700" title="New Folder">
                            <FolderPlus size={18} />
                          </button>
                        </div>
                        
                        <div className="space-y-1">
                          <div 
                            onClick={() => setSelectedFolder('all')}
                            className={`px-3 py-2 rounded cursor-pointer flex items-center gap-2 ${selectedFolder === 'all' ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100'}`}>
                            <Music size={16} />
                            <span className="text-sm">All Songs</span>
                            <span className="ml-auto text-xs text-gray-500">{songs.length}</span>
                          </div>
                          
                          {folders.map(folder => {
                            const folderSongs = songs.filter(s => s.folders && s.folders.includes(folder.id));
                            return (
                              <div key={folder.id}>
                                <div 
                                  onDragOver={(e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.currentTarget.style.backgroundColor = '#DBEAFE';
                                  }}
                                  onDragLeave={(e) => {
                                    e.currentTarget.style.backgroundColor = '';
                                  }}
                                  onDrop={(e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.currentTarget.style.backgroundColor = '';
                                    const songId = e.dataTransfer.getData('songId');
                                    console.log(' DROP on folder:', folder.name, 'songId:', songId);
                                    if (songId) {
                                      const updatedSongs = songs.map(s => {
                                        if (s.id === songId) {
                                          const folders = s.folders || [];
                                          if (!folders.includes(folder.id)) {
                                            console.log(' Adding song to folder');
                                            return { ...s, folders: [...folders, folder.id] };
                                          }
                                        }
                                        return s;
                                      });
                                      setSongs(updatedSongs);
                                      localStorage.setItem('chordTransposerSongs', JSON.stringify(updatedSongs));
                                    }
                                  }}
                                  className={`px-3 py-2 rounded cursor-pointer flex items-center gap-2 ${selectedFolder === folder.id ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100'}`}>
                                  <button onClick={(e) => { e.stopPropagation(); toggleFolderCollapse(folder.id); }} className="hover:text-gray-600">
                                    {collapsedFolders[folder.id] ? <ChevronRight size={14} /> : <ChevronDown size={14} />}
                                  </button>
                                  <Folder size={16} />
                                  <span onClick={() => setSelectedFolder(folder.id)} className="text-sm flex-1">{folder.name}</span>
                                  <span className="text-xs text-gray-500">{folderSongs.length}</span>
                                  <button onClick={(e) => { e.stopPropagation(); deleteFolder(folder.id); }} className="text-red-600 hover:text-red-700">
                                    <Trash2 size={14} />
                                  </button>
                                </div>
                              </div>
                            );
                          })}
                          
                          <div 
                            onClick={() => setSelectedFolder('uncategorized')}
                            className={`px-3 py-2 rounded cursor-pointer flex items-center gap-2 ${selectedFolder === 'uncategorized' ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-100'}`}>
                            <FileText size={16} />
                            <span className="text-sm">Uncategorized</span>
                            <span className="ml-auto text-xs text-gray-500">{songs.filter(s => !s.folders || s.folders.length === 0).length}</span>
                          </div>
                        </div>
                      </div>
                      
                      <div className="border-t border-gray-200 pt-4 mt-4">
                        <h3 className="text-sm font-semibold text-gray-700 mb-2">SONGS</h3>
                        {filteredSongs.length === 0 ? (
                          <p className="text-gray-400 text-sm text-center mt-8">{searchQuery ? 'No songs found' : 'No songs yet. Create your first one!'}</p>
                        ) : (
                          <div className="space-y-2">
                            {filteredSongs.map(song => (
                              <div key={song.id}
                                draggable="true"
                                onDragStart={(e) => {
                                  if (song.pinned) {
                                    handleDragStart(e, song);
                                  } else {
                                    // For folder drag & drop
                                    console.log(' DRAG START:', song.title, 'ID:', song.id);
                                    e.dataTransfer.setData('songId', song.id);
                                    e.dataTransfer.effectAllowed = 'copy';
                                    e.currentTarget.style.opacity = '0.5';
                                  }
                                }}
                                onDragOver={(e) => song.pinned && handleDragOver(e, song)}
                                onDragEnd={(e) => {
                                  handleDragEnd(e);
                                  e.currentTarget.style.opacity = '1';
                                }}
                                className={`p-3 rounded-lg border cursor-pointer hover:bg-gray-50 ${currentSong?.id === song.id ? 'bg-blue-50 border-blue-300' : 'border-gray-200'} ${song.pinned ? 'border-l-4 border-l-yellow-500' : ''}`}
                                onClick={() => loadSong(song)}>
                                <div className="flex items-start justify-between gap-2">
                                  {song.pinned && (
                                    <div className="hidden md:flex cursor-move text-gray-400 hover:text-gray-600 mt-1" title="Drag to reorder">
                                      <Menu size={16} />
                                    </div>
                                  )}
                                  <div className="flex-1">
                                    <div className="font-medium text-sm flex items-center gap-2">
                                      {song.pinned && <span className="text-yellow-500"></span>}
                                      {song.title}
                                    </div>
                                    <div className="text-xs text-gray-500 mt-1">
                                      Key: {song.originalKey}
                                      {song.bpm && `  ${song.bpm} BPM`}
                                      {song.timeSignature && `  ${song.timeSignature}`}
                                    </div>
                                  </div>
                                  <div className="flex flex-col gap-1">
                                    {/* Move up/down buttons for pinned songs - visible on mobile */}
                                    {song.pinned && (
                                      <div className="flex md:hidden flex-col gap-1">
                                        <button 
                                          onClick={(e) => movePinnedSongUp(song.id, e)} 
                                          className="text-gray-400 hover:text-blue-600 p-1"
                                          title="Move up"
                                        >
                                          
                                        </button>
                                        <button 
                                          onClick={(e) => movePinnedSongDown(song.id, e)} 
                                          className="text-gray-400 hover:text-blue-600 p-1"
                                          title="Move down"
                                        >
                                          
                                        </button>
                                      </div>
                                    )}
                                    <button onClick={(e) => togglePin(song.id, e)} className="text-gray-400 hover:text-yellow-500" title={song.pinned ? "Unpin" : "Pin"}>
                                      {song.pinned ? '' : ''}
                                    </button>
                                    <button onClick={(e) => { e.stopPropagation(); openMoveSongModal(song); }} className="text-gray-400 hover:text-blue-600" title="Add to folder">
                                      <Folder size={14} />
                                    </button>
                                  </div>
                                </div>
                                <button onClick={(e) => { e.stopPropagation(); deleteSong(song.id); }}
                                  className="mt-2 text-red-600 hover:text-red-700 text-xs flex items-center gap-1">
                                  <Trash2 size={12} />Delete
                                </button>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    </div>
                  </div>

                  <div className="flex-1 flex flex-col">
                    {/* Mobile Menu Button - Show when: (1) on mobile, (2) not in Performance/Live mode, (3) sidebar is closed */}
                    {!viewMode && !showLiveMode && !mobileMenuOpen && (
                      <button 
                        onClick={() => setMobileMenuOpen(true)}
                        className="md:hidden fixed top-4 left-4 z-50 bg-blue-600 text-white p-3 rounded-lg shadow-lg hover:bg-blue-700"
                        aria-label="Open menu"
                      >
                        <Menu size={24} />
                      </button>
                    )}
                    
                    {!currentSong && !showNewSong ? (
                      <div className="flex-1 flex items-center justify-center text-gray-400">
                        <div className="text-center">
                          <Music size={64} className="mx-auto mb-4 opacity-50" />
                          <p className="text-lg">Select a song or create a new one</p>
                        </div>
                      </div>
                    ) : editMode ? (
                      <div className="flex-1 overflow-y-auto p-8">
                        <div className="max-w-4xl mx-auto">
                          <div className="mb-4">
                            <label className="block text-sm font-medium text-gray-700 mb-2">Title</label>
                            <input type="text" value={title} onChange={(e) => setTitle(e.target.value)}
                              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Song title" />
                          </div>
                          
                          <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-2">Key (optional)</label>
                              <input type="text" value={songKey} onChange={(e) => setSongKey(e.target.value)}
                                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., C, Am, G" />
                            </div>
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-2">BPM (optional)</label>
                              <input type="text" value={bpm} onChange={(e) => setBpm(e.target.value)}
                                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 120" />
                            </div>
                          </div>
                          
                          <div className="mb-4">
                            <label className="block text-sm font-medium text-gray-700 mb-2">Time Signature (optional)</label>
                            <input type="text" value={timeSignature} onChange={(e) => setTimeSignature(e.target.value)}
                              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 4/4, 3/4, 6/8" />
                          </div>
                          
                          <div className="mb-4">
                            <label className="block text-sm font-medium text-gray-700 mb-2">Lyrics & Chords (use [Am] for chords, [Intro] [Verse 1] for sections)</label>
                            <div className="mb-2">
                              <button onClick={() => setShowImportModal(true)} className="text-sm bg-purple-600 text-white px-3 py-1 rounded hover:bg-purple-700">
                                Import from Text
                              </button>
                            </div>
                            <textarea value={content} onChange={(e) => setContent(e.target.value)}
                              className="w-full h-96 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono"
                              placeholder="Example:&#10;[Intro]&#10;[C]Hello [G]world&#10;&#10;[Verse 1]&#10;This is my [Am]song [F]today" />
                          </div>
                          
                          <div className="flex gap-2">
                            <button onClick={saveSong} className="flex items-center gap-2 bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
                              <Save size={20} />Save Song
                            </button>
                            <button onClick={cancelEdit} className="flex items-center gap-2 bg-gray-300 text-gray-700 px-6 py-2 rounded-lg hover:bg-gray-400">
                              <X size={20} />Cancel
                            </button>
                          </div>
                        </div>
                      </div>
                    ) : (
                      <>
                        <div className="bg-white border-b border-gray-200 p-4">
                          <div className="max-w-4xl mx-auto flex items-center justify-between performance-header-mobile">
                            <div className="song-info-mobile">
                              <h2 className="text-2xl font-bold">{currentSong.title}</h2>
                              <div className="text-sm text-gray-600 mt-1">
                                {transposition !== 0 ? (<span>Original: {currentSong.originalKey}, Current: {getCurrentKey()}</span>) : 
                                 (<span>Key: {currentSong.originalKey}</span>)}
                                {currentSong.bpm && <span>  {currentSong.bpm} BPM</span>}
                                {currentSong.timeSignature && <span>  {currentSong.timeSignature}</span>}
                              </div>
                            </div>
                            <div className="flex gap-2">
                              <button onClick={startEdit} className="flex items-center gap-2 text-blue-600 hover:text-blue-700">
                                <Edit size={20} />Edit
                              </button>
                              <button onClick={() => setViewMode(true)} className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">
                                <Music size={20} />Performance
                              </button>
                            </div>
                          </div>
                        </div>

                        <div className="bg-gray-100 border-b border-gray-200 p-4">
                          <div className="max-w-4xl mx-auto flex items-center justify-between flex-wrap gap-4">
                            <div className="flex items-center gap-4 transpose-control">
                              <span className="text-sm font-medium text-gray-700">Transpose:</span>
                              <div className="flex items-center gap-2">
                                <button onClick={() => setTransposition(t => t - 1)} className="w-10 h-10 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-bold">-</button>
                                <span className="w-16 text-center font-medium">{transposition > 0 ? '+' : ''}{transposition}</span>
                                <button onClick={() => setTransposition(t => t + 1)} className="w-10 h-10 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 font-bold">+</button>
                                {transposition !== 0 && (
                                  <button onClick={() => setTransposition(0)} className="ml-2 px-3 py-1 text-sm bg-gray-300 text-gray-700 rounded hover:bg-gray-400">Reset</button>
                                )}
                              </div>
                            </div>

                            <div className="flex gap-2 performance-buttons">
                              <button onClick={copyToClipboard} className="flex items-center gap-2 bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700">
                                <Copy size={18} />Copy
                              </button>
                              <button onClick={exportToPDF} className="flex items-center gap-2 bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700">
                                <Download size={18} />PDF
                              </button>
                              <button onClick={exportToWord} className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">
                                <FileText size={18} />DOC
                              </button>
                            </div>
                          </div>
                        </div>

                        <div className="flex-1 overflow-y-auto p-8 bg-white">
                          <div className="max-w-4xl mx-auto font-mono whitespace-pre-wrap">
                            {formatContent(filterMeasureLines(currentSong.content), transposition).map((line, i) => (
                              <div key={i} className="leading-relaxed">
                                {line.isEmpty ? (<br />) : (
                                  line.parts.map((part, j) => (
                                    <span key={j} className={part.type === 'chord' ? 'font-bold text-black' : 
                                      part.type === 'section' ? 'block text-xl font-bold text-blue-700 mt-4 mb-2' : ''}>
                                      {part.content}
                                    </span>
                                  ))
                                )}
                              </div>
                            ))}
                          </div>
                        </div>
                      </>
                    )}
                  </div>
                </>
              )}
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ChordTransposer />);
    </script>
</body>
</html>
